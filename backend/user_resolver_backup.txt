package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"encoding/base64"
	"fmt"
	"net/url"

	"github.com/FlxdeCat/faREbook-backend/graph/model"
	"github.com/FlxdeCat/faREbook-backend/helper"
	"github.com/google/uuid"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, user model.NewUser) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: Register - register"))
	passwordHash, err := helper.ConvertPasswordSalt(user.Password)
	if err != nil {
		return nil, err
	} else {
		newUser := &model.User{
			ID:        uuid.NewString(),
			Username:  user.Username,
			Firstname: user.Firstname,
			Lastname:  user.Lastname,
			Dob:       user.Dob,
			Gender:    user.Gender,
			Email:     user.Email,
			Password:  passwordHash,
			Activated: user.Activated,
		}
		if err := helper.SendActiveEmail(newUser); err != nil {
			return nil, err
		} else {
			return newUser, r.DB.Save(&newUser).Error
		}
	}
}

// ActivateUser is the resolver for the ActivateUser field.
func (r *mutationResolver) ActivateUser(ctx context.Context, usr string) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: ActivateUser - ActivateUser"))
	tempUSR, err := url.QueryUnescape(usr)
	if err != nil {
		return nil, err
	}
	decodeUSR, err := base64.RawStdEncoding.DecodeString(tempUSR)
	if err != nil {
		return nil, err
	}
	id, err := helper.ExtractUserIDFromJWT(string(decodeUSR))
	if err != nil {
		return nil, err
	}
	var newUser *model.User
	if err := r.DB.First(&newUser, "id = ?", id).Error; err != nil {
		return nil, err
	} else {
		if err != nil {
			return nil, err
		} else {
			newUser.Activated = true
		}
	}
	return newUser, r.DB.Save(&newUser).Error
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, user model.NewUser) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
	var newUser *model.User
	if err := r.DB.First(&newUser, "id = ?", id).Error; err != nil {
		return nil, err
	} else {
		if err != nil {
			return nil, err
		} else {
			newUser.Username = user.Username
			newUser.Firstname = user.Firstname
			newUser.Lastname = user.Lastname
			newUser.Dob = user.Dob
			newUser.Gender = user.Gender
		}
	}
	return newUser, r.DB.Save(&newUser).Error
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, usr string, password string) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: ResetPassword - resetPassword"))
	tempUSR, err := url.QueryUnescape(usr)
	if err != nil {
		return nil, err
	}
	decodeUSR, err := base64.RawStdEncoding.DecodeString(tempUSR)
	if err != nil {
		return nil, err
	}
	id, err := helper.ExtractUserIDFromJWT(string(decodeUSR))
	if err != nil {
		return nil, err
	}
	var newUser *model.User
	if err := r.DB.First(&newUser, "id = ?", id).Error; err != nil {
		return nil, err
	} else {
		if err != nil {
			return nil, err
		} else if helper.CheckPasswordSalt(newUser.Password, password) {
			return nil, fmt.Errorf("password cannot be the same as original")
		} else {
			newPassword, err := helper.ConvertPasswordSalt(password)
			if err != nil {
				return nil, err
			} else {
				newUser.Password = newPassword
			}
		}
	}
	return newUser, r.DB.Save(&newUser).Error
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (string, error) {
	// panic(fmt.Errorf("not implemented: Login - login"))
	var newUser *model.User
	if err := r.DB.First(&newUser, "email = ?", email).Error; err != nil {
		return "", err
	} else {
		if !helper.CheckPasswordSalt(newUser.Password, password) {
			return "", fmt.Errorf("incorrect password")
		} else if !newUser.Activated {
			return "", fmt.Errorf("account not activate")
		}
		return helper.UserConvertJWT(newUser)
	}
}

// SendForgotEmail is the resolver for the sendForgotEmail field.
func (r *mutationResolver) SendForgotEmail(ctx context.Context, email string) (string, error) {
	// panic(fmt.Errorf("not implemented: SendForgotEmail - sendForgotEmail"))
	var newUser *model.User
	if err := r.DB.First(&newUser, "email = ?", email).Error; err != nil {
		return "", err
	} else {
		if err := helper.SendForgotEmail(newUser); err != nil {
			return "", err
		} else {
			return helper.UserConvertJWT(newUser)
		}
	}
}

// ValidateUser is the resolver for the validateUser field.
func (r *queryResolver) ValidateUser(ctx context.Context, usr string) (bool, error) {
	// panic(fmt.Errorf("not implemented: ValidateUser - validateUser"))
	tempUSR, err := url.QueryUnescape(usr)
	if err != nil {
		return false, err
	}
	decodeUSR, err := base64.RawStdEncoding.DecodeString(tempUSR)
	if err != nil {
		return false, err
	}
	id, err := helper.ExtractUserIDFromJWT(string(decodeUSR))
	if err != nil {
		return false, err
	}
	var newUser *model.User
	if err := r.DB.First(&newUser, "id = ?", id).Error; err != nil {
		return false, err
	} else {
		return true, nil
	}
}

// ValidateUserJwt is the resolver for the validateUserJWT field.
func (r *queryResolver) ValidateUserJwt(ctx context.Context, jwt string) (bool, error) {
	// panic(fmt.Errorf("not implemented: ValidateUserJwt - validateUserJWT"))
	id, err := helper.ExtractUserIDFromJWT(jwt)
	if err != nil {
		return false, nil
	}
	var newUser *model.User
	if err := r.DB.First(&newUser, "id = ?", id).Error; err != nil {
		return false, nil
	} else {
		return newUser.Activated, nil
	}
}

// GetUserOnJwt is the resolver for the getUserOnJWT field.
func (r *queryResolver) GetUserOnJwt(ctx context.Context, jwt string) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: GetUserOnJwt - getUserOnJWT"))
	var newUser *model.User
	if id, err := helper.ExtractUserIDFromJWT(jwt); err != nil {
		return nil, err
	} else {
		if err := r.DB.First(&newUser, "id = ?", id).Error; err != nil {
			return nil, err
		} else {
			return newUser, nil
		}
	}
}

// GetUserOnID is the resolver for the getUserOnID field.
func (r *queryResolver) GetUserOnID(ctx context.Context, id string) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: GetUserOnID - getUserOnID"))
	var newUser *model.User
	if err := r.DB.First(&newUser, "id = ?", id).Error; err != nil {
		return nil, err
	} else {
		return newUser, nil
	}
}

// GetAllActivatedUser is the resolver for the getAllActivatedUser field.
func (r *queryResolver) GetAllActivatedUser(ctx context.Context) ([]*model.User, error) {
	// panic(fmt.Errorf("not implemented: GetAllActivatedUser - getAllActivatedUser"))
	var users []*model.User
	return users, r.DB.Find(&users, "activated = ?", true).Error
}

// CompareUserIDWithJwt is the resolver for the compareUserIDWithJWT field.
func (r *queryResolver) CompareUserIDWithJwt(ctx context.Context, id string, jwt string) (bool, error) {
	// panic(fmt.Errorf("not implemented: CompareUserIDWithJwt - compareUserIDWithJWT"))
	if jwt_id, err := helper.ExtractUserIDFromJWT(jwt); err != nil {
		return false, nil
	} else {
		return id == jwt_id, nil
	}
}

// GetUserFriends is the resolver for the getUserFriends field.
func (r *queryResolver) GetUserFriends(ctx context.Context, id string) ([]*model.Friend, error) {
	panic(fmt.Errorf("not implemented: GetUserFriends - getUserFriends"))
}

// GetAllUserFriends is the resolver for the getAllUserFriends field.
func (r *queryResolver) GetAllUserFriends(ctx context.Context) ([]*model.Friend, error) {
	panic(fmt.Errorf("not implemented: GetAllUserFriends - getAllUserFriends"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
