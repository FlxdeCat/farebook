package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"time"

	"github.com/FlxdeCat/faREbook-backend/graph/model"
	"github.com/FlxdeCat/faREbook-backend/helper"
	"github.com/FlxdeCat/faREbook-backend/service"
	"github.com/google/uuid"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, newPost model.NewPost) (*model.Post, error) {
	// panic(fmt.Errorf("not implemented: CreatePost - createPost"))
	id, err := helper.ExtractUserIDFromJWT(newPost.UserJwt)
	if err != nil {
		return nil, err
	}
	post := &model.Post{
		ID:        uuid.NewString(),
		PosterID:  id,
		PostTag:   newPost.PostTag,
		Content:   newPost.Content,
		Type:      newPost.Type,
		CreatedAt: time.Now(),
		GroupID:   newPost.GroupID,
	}
	return post, r.DB.Create(&post).Error
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, postID string) (*model.Post, error) {
	// panic(fmt.Errorf("not implemented: DeletePost - deletePost"))
	var post *model.Post
	if err := r.DB.First(&post, "id = ?", postID).Error; err != nil {
		return nil, err
	} else {
		return post, r.DB.Delete(&post).Error
	}
}

// Poster is the resolver for the poster field.
func (r *postResolver) Poster(ctx context.Context, obj *model.Post) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: Poster - poster"))
	return service.GetUser(ctx, obj.PosterID)
}

// Group is the resolver for the group field.
func (r *postResolver) Group(ctx context.Context, obj *model.Post) (*model.Group, error) {
	// panic(fmt.Errorf("not implemented: Group - group"))
	if obj.GroupID == nil {
		return nil, nil
	}
	return service.GetGroup(ctx, *obj.GroupID)
}

// GetPostForUser is the resolver for the getPostForUser field.
func (r *queryResolver) GetPostForUser(ctx context.Context, userJwt string, offset int) ([]*model.Post, error) {
	// panic(fmt.Errorf("not implemented: GetPostForUser - getPostForUser"))
	id, err := helper.ExtractUserIDFromJWT(userJwt)
	if err != nil {
		return nil, err
	}

	var allPosts []*model.Post
	var posts []*model.Post
	if err := r.DB.Order("created_at DESC").Find(&allPosts).Error; err != nil {
		return allPosts, err
	}
	for _, post := range allPosts {
		if post.PosterID == id || post.Type == "Public" {
			posts = append(posts, post)
			continue
		}
		var friend *model.Friend
		if post.Type == "Friend" {
			if err := r.DB.First(&friend, "user_id = ? and friend_id = ? and status != 'Request'", post.PosterID, id).Error; err != nil {
				continue
			} else {
				posts = append(posts, post)
			}
		}
		if post.Type == "Private" {
			if err := r.DB.First(&friend, "user_id = ? and friend_id = ? and status = 'Close'", post.PosterID, id).Error; err != nil {
				continue
			} else {
				posts = append(posts, post)
			}
		}
	}
	var empty []*model.Post
	start := offset * 5
	if start > len(posts) {
		return empty, nil
	}
	end := (offset + 1) * 5
	if end > len(posts) {
		end = len(posts)
	}
	return posts[start:end], nil
}

// GetUserPost is the resolver for the getUserPost field.
func (r *queryResolver) GetUserPost(ctx context.Context, posterID string, userJwt string, offset int) ([]*model.Post, error) {
	// panic(fmt.Errorf("not implemented: GetUserPost - getUserPost"))
	id, err := helper.ExtractUserIDFromJWT(userJwt)
	if err != nil {
		return nil, err
	}

	var allPosts []*model.Post
	var posts []*model.Post
	if err := r.DB.Order("created_at DESC").Find(&allPosts, "poster_id = ?", posterID).Error; err != nil {
		return allPosts, err
	}
	for _, post := range allPosts {
		if post.PosterID == id || post.Type == "Public" {
			posts = append(posts, post)
			continue
		}
		var friend *model.Friend
		if post.Type == "Friend" {
			if err := r.DB.First(&friend, "user_id = ? and friend_id = ? and status != 'Request'", post.PosterID, id).Error; err != nil {
				continue
			} else {
				posts = append(posts, post)
			}
		}
		if post.Type == "Private" {
			if err := r.DB.First(&friend, "user_id = ? and friend_id = ? and status = 'Close'", post.PosterID, id).Error; err != nil {
				continue
			} else {
				posts = append(posts, post)
			}
		}
	}
	var empty []*model.Post
	start := offset * 5
	if start > len(posts) {
		return empty, nil
	}
	end := (offset + 1) * 5
	if end > len(posts) {
		end = len(posts)
	}
	return posts[start:end], nil
}

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

type postResolver struct{ *Resolver }
